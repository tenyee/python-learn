#!/bin/env python
# -*- coding:utf-8 -*-

'''
本小节是针对闭包与装饰器进行分析、理解

1.何为闭包？
	从Python闭包函数的表现形式看，如果一个外层函数outter的内部函数inner，inner
	对外层函数outter的变量（这是一个外层非全局变量，注意并不是全局变量）进行引
	用，那么这个inner就是一个闭包。
	两个条件：
	（1）内部函数；
	（2）对外层函数的局部变量进行引用（这叫外层局部变量，区分全局变量）

	@从闭包的用途来看，外层函数通常会返回内部函数名，否则闭包没啥作用

下面看一下例子
'''

'''
example-1 
这个例子中，inner引用了outter的局部变量o_var，最后outter返回了inner，这就是一个
最简单的闭包了，只是没啥用

'''
def Outter():
	o_var = 0
	def Inner():
		#o_var = 1    #去掉注释后，o_var是Inner的局部变量
		i_var = o_var
		#o_var = 1    #这认为o_var被定义在inner,去掉后，会运行报错，原因是python
					  #在生成可执行代码时，扫描到o_var在inne中被定义过，于是，
					  #当成局部变量，而i_var = o_var先于变量定义，于是出错。
					  #python会先扫描代码确定变量，然后再执行。
		return i_var

	return Inner

'''
example-2
这是一个计数器，每调用一次Counter()就会返回一个初始值可以设定的步进为1的计数器，
计数器间相互独立，从这个例子应该能感受到闭包的意思了吧

分析：
	首先从计数器的功能来分析，我们希望每调用一次计数器生成器，我们就能得到一个
	计数器，且可以设定从不同的值开始计数，如：
	c1 = Counter(1)
	c2 = Counter(10)

	c1()   -- 1
	c1()   -- 2
	c2()   -- 10
	c2()   -- 11

	可以看到，c1,c2是相互独立的，这就是神奇的闭包

	从下面的函数来看：
	Inner引用了外层变量sum，但你应该注意到多了个声明nonlocal，如果我们去掉这一
	行，那么，运行报错。
	为什么？python的变量定义是这么操作的，python解释器会先扫描一下代码块，把左值
	理解为是一个定义，于是，它看到sum是一个左值，被赋值 ，认为它是一个定义变量的
	过程，因为要给这个变量赋值，于是它就去计算右边的表达式，当它找到sum 时，发现
	这个值并没有被定义，于是报错。你会问，难道它不会去找外层的sum吗？个人理解不
	会，因为它已经认为sum是一个局部变量了，就像函数的局部变量会屏蔽全局变量一样。

	为了告诉解释器，sum不是一个局部变量，它是一个外层变量，py3引入了nonlocal，注
	意，和global不是一个作用。

	可以看到，sum 与 Inner绑定在一起了，每次调用Inner时，会自动在sum 上递增，这
	种感觉是不是觉得sum 是一个全局变量或者其它语言的静态局部变量？你可以也可这样
	理解。

	另外，对于py2系列，并没有nonlocal关键字，可以利用可变对象来做如下：

	def Counter(start):
		sum = [start - 1]
		def Inner():
			sum[0] = sum[0] + 1
			return sum[0] 

		return Inner

	内部函数可以访问外部函数的变量，没毛病。
	另外，有人说，内部函数无法改变外部函数的变量，我觉得这样说不太对，不是无法改
	变，是因为当你o_var = xxx 时，相当于定义了一个局部变量，这个变量屏蔽了外部变
	量。要不然，无法改变，那上面的例子为什么又能改变，对吧。


'''
def Counter(start):
	sum = start - 1
	def Inner():
		nonlocal sum 
		sum = sum + 1
		return sum 

	return Inner


################################################################################
#总结：
#闭包两个条件：（1）内部函数，通常会返回；
#			   （2）内部函数引用外层变量。
#注意，要搞清楚变量的定义与查找顺序
#python引用变量的顺序： 当前作用域局部变量->外层作用域变量->当前模块中的全局变量
#                       ->python内置变量
#同名情况下，会屏蔽后面的变量
################################################################################

'''
2.装饰器
	有了上面的理解，装饰器就简单了。简单点说，装饰器的作用就是在不改变原有函数的
基础上，为函数加入一些功能，比如计算函数运行时间，写日志等等。
	利用的特性为函数是第一类值，也就是说，函数可以当参数，可以当返回值，就像变量
一样。
	
看例子
'''

'''
example-1
一个简单的装饰器，可以在函数运行前打印一条日志

'''

def LogDebug(func):
	def WrapFunc(*arg1, **arg2):
		print("[Debug]....")
		return func(*arg1, **arg2)

	return WrapFunc

def foo():
	print("foo")

'''
调用方式
'''
logFoo = LogDebug(foo)
logFoo()

#上面的调用是不是觉得很烦，python做了一个语法糖，可以这么玩
@LogDebug   #相当于  bar = LogDebug(bar)
def bar(a, b, c):
	print("bar")

bar(1,2,3)

'''
example-2
类装饰器
当一个类被当装饰使用时，会调用内部的魔法函数__call__，代码如下
'''
class CLogWarn:
	def __init__(self, func):
		self.func = func

	def __call__(self, *arg1, **arg2):
		print("[Warn]....")
		return self.func(*arg1, **arg2)

@CLogWarn  #相当于  tom = CLogWarn(tom)
def tom():
	print("tom")

tom()

################################################################################
#总结：
#装饰器就是一个闭包的应用，引用了外层函数的变量，能够在不改变原有的逻辑情况下，
#为函数增加额外的功能
################################################################################